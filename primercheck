import random
import hashlib
import binascii
def gcd(a, b):
    # Base Case
    if a == 0 :
        return b,0,1
             
    gcd,x1,y1 = gcd(b%a, a)
     
    # Update x and y using results of recursive
    # call
    x = y1 - (b//a) * x1
    y = x1
     
    return gcd,x,y
     
 

def generate_large_prime():
    while True:
        p = random.getrandbits(1024)
        if is_prime(p):
            return p

def is_prime(n, k=5):
    if n <= 3:
        return n == 2 or n == 3
    for i in range(k):
        a = random.randint(2, n-2)
        x = pow(a, n-1, n)
        if x != 1:
            return False
    return True

def mot10char():
    return ''.join(random.choices('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890', k=10))

p1 = generate_large_prime()
p2 = generate_large_prime()
q1 = generate_large_prime()
q2 = generate_large_prime()

na = p1 * p2
phia = (p1-1)*(p2-1)//gcd(p1-1,p2-1)[2]
ea = 65537
da = modinv(ea, phia)

nb = q1 * q2
phib = (q1-1)*(q2-1)//gcd(q1-1,q2-1)[2]
eb = 65537
db = modinv(eb, phib)

print("Alice's public key: ")
print("n =", na)
print("e =", ea)

print("Alice's private key: ")
print("d =", da)

print("Bob's public key: ")
print("n =", nb)
print("e =", eb)

print("Bob's private key: ")
print("d =", db)

secret = mot10char()
print("Message to be encrypted:", secret)

num_sec = int.from_bytes(secret.encode('utf-8'), 'big')

cipher = pow(num_sec, ea, na)
print("Encrypted message:", cipher)

hash_val = hashlib.sha256(secret.encode('utf-8')).digest()
hash_num = int.from_bytes(hash_val, 'big')
signature = pow(hash_num, db, nb)
print("Signature:", signature)

decrypt = pow(cipher, da, na)
decrypted_message = decrypt.to_bytes((decrypt.bit_length() + 7) // 8, 'big').decode('utf-8')
print("Decrypted message:", decrypted_message)

verify = pow(signature, eb, nb)
if verify == hash_num:
    print("Signature is valid.")
else:
    print("Invalid signature.")